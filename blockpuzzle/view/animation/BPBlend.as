import blockpuzzle.view.sprite.BPSpriteChange;import blockpuzzle.view.animation.*;class blockpuzzle.view.animation.BPBlend extends BPAnimation {    // Data object variables    var sprite:BPSpriteChange;    var update:Object;        // Animation parametric values        var initial:Number;    var by:Number;    var final:Number;    var rate:Number;    var duration:Number;    var method:String;    var blend:Function;        var instant:Boolean;        // For sequencing blends...    var nextBlend:BPBlend;    var thisSignal:String;    var waitingFor:String;        // Current Status    var startNow:Boolean;    var isStarted:Boolean;    var isEnded:Boolean;    /**************    *             *    * Constructor *    *             *    **************/    function BPBlend(sprite:BPSpriteChange, method:String, options) {        super(sprite.sprite);		this.method    = method;//        super(sprite.sprite);                this.sprite    = sprite;        this.update    = new Object();                this.initial   = options.from;        this.final     = (options.to == null) ? options.via : options.to;        this.by        = options.by;        this.rate      = options.speed;        this.duration  = options.seconds;        this.instant   = (options.instant == null) ? (options.speed == null && options.seconds == null) : options.instant;        this.blend     = blendingFunction(options.blend);        if (this.final == null) this.final = options.control;    }    function blendingFunction(fcn):Function {        if (fcn instanceof Function)            return fcn;        else if (fcn)            return BPBlend[fcn];        else            return linear;    }    /****************    *               *    * Clock Methods *    *               *    ****************/    function value(completion:Number):Number {        return initial + (final - initial) * completion;    }        function blendedCompletion(timeCompletion:Number):Number {        return blend.call(null, timeCompletion);    }        /******************    *                 *    * Animation Frame *    *                 *    ******************/    function setup() {        if (initial == null) initial = sprite.get(method);        if (by != null)      final = initial + by;                if (duration == null) duration = Math.abs(final - initial) / rate;        setupBlend();    }    function animate(completion:Number) {        var comp = blendedCompletion(completion);        sprite.change(method, value(comp));    }    function setupBlend() {        if (instant) {            listenFor("BPAnimationStart", this, finish);        } else if (! isNaN(duration)) {            endInSecondsAfterStart(duration);        }    }    /*********************    *                    *    * Blending Functions *    *                    *    *********************/    static function linear(input:Number):Number { return input; }        static function smooth(input:Number):Number { return 0.5 * (1.0 - Math.cos(Math.PI * input)); }    static function   snap(input:Number):Number { return Math.sqrt(input); }    static function  accel(input:Number):Number { return Math.pow(input, 2.0); }        static function bounce(input:Number):Number { return 4.0 * input * (1.0 - input); }        /******************    *                 *    * Utility methods *    *                 *    ******************/        function toString():String {        return "Blend{ " + target + " : " + method + " @ " + waiting() + " }";    }}